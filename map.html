<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2050 Population Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #e9ecef;
            overflow: hidden;
        }
        body {
            padding: 15px;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            padding: 15px;
            max-width: 100%;
            height: calc(100vh - 60px);
            display: flex;
            flex-direction: column;
        }
        #map {
            width: 100%;
            flex: 1;
            border: 1px solid #ddd;
            background: #fff;
            margin: 5px 0;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 0;
        }
        .city {
            stroke: #333;
            stroke-width: 0.1;
        }
        .city:hover {
            fill: rgba(255, 107, 107, 0);
            stroke: #ff6b6b;
            stroke-width: 0.1;
        }
        #controls {
            text-align: center;
            margin: 5px 0;
            padding: 6px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        .year-btn {
            padding: 4px 8px;
            margin: 0 2px;
            font-size: 11px;
            border: 1px solid #ccc;
            background: #f8f9fa;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
            color: #666;
        }
        .year-btn.active {
            background: #333;
            color: white;
            border-color: #333;
        }
        .year-btn:hover {
            background: #e9ecef;
            border-color: #999;
        }
        .animation-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            justify-content: center;
        }
        .year-indicator {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 4px 8px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 11px;
            color: #495057;
            display: inline-block;
            margin: 0 4px;
        }
        #legend {
            margin: 5px auto;
            max-width: 100%;
            padding: 6px 12px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        .legend-item {
            display: inline-block;
            margin: 0;
        }
        .legend-color {
            display: inline-block;
            width: 16px;
            height: 12px;
            margin-right: 6px;
            border: 1px solid #333;
            vertical-align: middle;
        }
        .legend-line {
            display: inline-block;
            width: 16px;
            height: 2px;
            margin-right: 6px;
            background: red;
            vertical-align: middle;
        }
        .zoom-controls {
            display: inline-block;
            margin-left: 15px;
        }
        .zoom-btn {
            padding: 4px 8px;
            margin: 0 2px;
            font-size: 11px;
            border: 1px solid #ccc;
            background: #f8f9fa;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
            color: #666;
        }
        .zoom-btn:hover {
            background: #e9ecef;
            border-color: #999;
        }
        .animation-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="font-size: 16px; margin: 2px 0; color: #333; font-weight: 500; flex-shrink: 0;">West Africa Agglomeration Growth 2025-2050</h1>
        <div id="controls">
            <div class="animation-controls">
                <button id="playPause" class="year-btn active">⏸ Pause</button>
                <button id="resetAnimation" class="year-btn">Reset</button>
                <div class="year-indicator">
                    <span id="currentYearDisplay">2025</span>
                </div>
                <span style="font-size: 12px; font-weight: 500; color: #666; margin-left: 15px;">Population:</span>
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div class="legend-gradient" style="background: linear-gradient(to right, #E4E3BE, #8E4728); height: 12px; width: 120px; border: 1px solid #ccc; border-radius: 2px;"></div>
                    <div style="display: flex; justify-content: space-between; width: 120px; font-size: 10px; color: #666;">
                        <span>1K</span>
                        <span>50M</span>
                    </div>
                </div>
                <div style="display: flex; align-items: center; margin-left: 10px;">
                    <div style="width: 16px; height: 2px; background: repeating-linear-gradient(to right, #ff6b6b 0px, #ff6b6b 3px, transparent 3px, transparent 6px); margin-right: 6px;"></div>
                    <span style="font-size: 10px; color: #666;">Merge flow</span>
                </div>
                <div class="zoom-controls" style="margin-left: 15px;">
                    <button id="zoomIn" class="zoom-btn">+</button>
                    <button id="zoomOut" class="zoom-btn">−</button>
                    <button id="resetZoom" class="zoom-btn">⌂</button>
                </div>
            </div>
        </div>
    <div id="map"></div>
    <div id="info-panel" style="position: fixed; top: 10px; right: 10px; background: white; border: 1px solid #ccc; padding: 10px; max-width: 400px; max-height: 80vh; overflow-y: auto; display: none; z-index: 1000; font-size: 12px;">
        <h4>City Info</h4>
        <div id="info-content"></div>
        <button id="close-info" style="margin-top: 10px;">Close</button>
    </div>

    <script>
        // Set up the SVG - responsive to container
        const width = 1400;
        const height = 700;
        
        const svg = d3.select("#map")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("preserveAspectRatio", "xMidYMid meet");

        // Add zoom functionality with wider range to show Africa
        const zoom = d3.zoom()
            .scaleExtent([0.1, 20]) // Wider range: 0.1x to 20x zoom
            .on("zoom", function(event) {
                g.attr("transform", event.transform);
            });

        svg.call(zoom)
            .on("click", function() {
                // Click on empty space to close info panel
                d3.select("#info-panel").style("display", "none");
            });

        // Create a group for all map elements
        const g = svg.append("g");

        // Create projection - focused on Lagos area
        const projection = d3.geoMercator()
            .center([3.4, 6.5]) // Center on Lagos area (longitude, latitude)
            .scale(8000) // Higher scale for closer view
            .translate([width / 2, height / 2]);

        const path = d3.geoPath().projection(projection);

        // Create continuous color scale
        const colorScale = d3.scaleLinear()
            .domain([1000, 50000000]) // Population range
            .range(["#E4E3BE", "#8E4728"]); // Light beige to dark brown

        // West African countries (ISO3 codes)
        const westAfricanCountries = [
            'BEN', 'BFA', 'CPV', 'CIV', 'GMB', 'GHA', 'GIN', 'GNB', 'LBR', 
            'MLI', 'MRT', 'NER', 'NGA', 'SEN', 'SLE', 'TGO'
        ];

        let currentYear = "2025";
        let data2025 = null;
        let data2050 = null;
        let currentData = null;
        
        // Animation variables
        let isPlaying = true;
        let animationInterval = null;
        let animationSpeed = 5500; // seconds between transitions
        let lastTransitionTime = 0;
        let currentPhase = "2025_display"; // 2025_display, 2025_to_2050, 2050_display, 2050_to_2025

        // Function to filter data for West Africa only
        function filterWestAfrica(data) {
            if (!data || !data.features) return data;
            
            const filteredFeatures = data.features.filter(feature => {
                const iso3 = feature.properties.ISO3;
                return westAfricanCountries.includes(iso3);
            });
            
            return {
                ...data,
                features: filteredFeatures
            };
        }

        // Animation control functions
        function startAnimation() {
            if (animationInterval) return;
            
            animationInterval = setInterval(() => {
                if (isPlaying) {
                    switchYear();
                }
            }, animationSpeed);
        }

        function stopAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        function switchYear() {
            if (currentYear === "2025") {
                // Transition from 2025 to 2050 with smooth animation
                currentYear = "2050";
                updateYearDisplay();
                
                // Debug: Log animation trigger
                console.log("Switching to 2050, triggering merge animation");
                
                // First: Animate merging cities moving to their target cities (1 second)
                animateMergingCities();
                
                // Then: Update opacity for both year groups with smooth transitions (1.5 seconds for both)
                // Use a delay to start after the movement animation is completely finished
                setTimeout(() => {
                    // 对于2025年城市：只对非合并城市进行淡出，合并城市保持隐藏状态
                    g.selectAll(".city-2025")
                        .filter(function(d) {
                            // 只对非合并城市进行淡出动画
                            const mergedTo = d.properties.MergedTo;
                            return !mergedTo || mergedTo <= 0 || mergedTo === d.properties.Agglomeration_ID;
                        })
                        .style("opacity", 1)  // 确保从可见状态开始
                        .transition()
                        .duration(300)  // 2025年渐隐：0.3秒
                        .ease(d3.easeLinear)  // 使用线性缓动，减少计算负担
                        .style("opacity", 0);
                    
                    // 合并的城市保持隐藏状态，不进行淡出动画
                    g.selectAll(".city-2025")
                        .filter(function(d) {
                            const mergedTo = d.properties.MergedTo;
                            return mergedTo && mergedTo > 0 && mergedTo !== d.properties.Agglomeration_ID;
                        })
                        .style("opacity", 0);  // 保持隐藏状态
                    
                    g.selectAll(".city-2050")
                        .style("opacity", 0)  // 确保从不可见状态开始
                        .transition()
                        .duration(300)  // 2050年渐显：0.3秒（与2025年渐隐同步）
                        .ease(d3.easeLinear)  // 使用线性缓动，减少计算负担
                        .style("opacity", 1);
                    
                    // 在2050年完全显示后，重新渲染地图并重置线条位置
                    setTimeout(() => {
                        // Re-render map to ensure merge lines exist for 2050 and reset to original positions
                        renderMap();
                    }, 300); // 等待2050年完全显示后再重置线条
                }, 3200); // 延迟3.2秒，确保移动动画完全完成
                
                // Keep merge lines visible during 2025→2050 transition (they maintain shifted positions)
                g.selectAll(".merge-line")
                    .style("opacity", 0.5);  // 线条保持可见，保持移位位置
                    
            } else {
                // Cross-fade from 2050 to 2025: 2025 fades out while 2050 fades in
                currentYear = "2025";
                updateYearDisplay();
                
                // Re-render map to recreate merge lines
                renderMap();
                
                // 2050年直接消失，2025年直接出现（无过渡）
                g.selectAll(".city-2050")
                    .style("opacity", 0);  // 2050年直接消失
                
                g.selectAll(".city-2025")
                    .style("opacity", 1);  // 2025年直接出现
                
                // Merge lines fade in (3 seconds) - but don't affect animation speed
                g.selectAll(".merge-line")
                    .style("opacity", 0.5);  // 2025年时线条更明显，不影响动画速度
            }
        }

        function updateYearDisplay() {
            d3.select("#currentYearDisplay").text(currentYear);
        }
        
        function animateMergingCities() {
            // Use dynamic area filtering based on zoom level
            const zoomLevel = d3.zoomTransform(svg.node()).k || 1;
            const baseThreshold = 100000;
            const dynamicThreshold = baseThreshold * Math.pow(2, Math.max(0, Math.log2(zoomLevel) - 2));
            
            const filteredData2025 = data2025.features.filter(function(d) {
                const bounds = path.bounds(d);
                const area = (bounds[1][0] - bounds[0][0]) * (bounds[1][1] - bounds[0][1]);
                return area < dynamicThreshold;
            });
            
            // Find all cities that will be merged (only from filtered data)
            const mergingCities = filteredData2025.filter(city => {
                const mergedTo = city.properties.MergedTo;
                return mergedTo && mergedTo > 0 && mergedTo !== city.properties.Agglomeration_ID;
            });
            
            // Debug: Log merging cities
            console.log("Found merging cities:", mergingCities.length);
            if (mergingCities.length > 0) {
                console.log("First merging city:", mergingCities[0].properties.Agglomeration_Name, "merges to:", mergingCities[0].properties.MergedTo);
            }
            
            // If no merging cities found, create a test case
            if (mergingCities.length === 0) {
                console.log("No merging cities found, creating test case");
                // Find two cities to create a test merge
                const testCities = filteredData2025.slice(0, 2);
                if (testCities.length >= 2) {
                    // Create a test merge
                    const testMerge = {
                        source: testCities[0],
                        target: testCities[1],
                        sourceId: testCities[0].properties.Agglomeration_ID,
                        targetId: testCities[1].properties.Agglomeration_ID
                    };
                    console.log("Creating test merge from", testMerge.source.properties.Agglomeration_Name, "to", testMerge.target.properties.Agglomeration_Name);
                    animateSingleMerge(testMerge);
                }
                return;
            }
            
            mergingCities.forEach(sourceCity => {
                const sourceId = sourceCity.properties.Agglomeration_ID;
                const mergedTo = sourceCity.properties.MergedTo;
                
                // Find the target city in the filtered data
                const targetCity = filteredData2025.find(city => 
                    city.properties.Agglomeration_ID === mergedTo
                );
                
                // Validate that target city exists and is not filtered out
                if (targetCity) {
                    // Additional validation: check if target city has valid coordinates
                    const targetCentroid = path.centroid(targetCity);
                    if (isNaN(targetCentroid[0]) || isNaN(targetCentroid[1])) {
                        console.warn(`Target city ${targetCity.properties.Agglomeration_Name} (ID: ${mergedTo}) has invalid coordinates, skipping merge animation`);
                        return;
                    }
                    const sourceCentroid = path.centroid(sourceCity);
                    
                    // Find the corresponding 2025 city element
                    const cityElement = g.selectAll(".city-2025")
                        .filter(function(d) {
                            return d.properties.Agglomeration_ID === sourceId;
                        });
                    
                    // Find the corresponding merge line
                    const mergeLine = g.selectAll(".merge-line")
                        .filter(function(d) {
                            return d.sourceId === sourceId && d.targetId === mergedTo;
                        });
                    
                    if (!cityElement.empty()) {
                        // Hide the original city immediately
                        cityElement.style("opacity", 0);
                        
                        // Create a temporary group for the moving city
                        const movingGroup = g.append("g")
                            .attr("class", "moving-city")
                            .style("opacity", 1);
                        
                        // Clone the city path to the moving group with complete styling
                        const cityPath = cityElement.attr("d");
                        movingGroup.append("path")
                            .attr("d", cityPath)
                            .attr("fill", cityElement.attr("fill"))
                            .attr("stroke", cityElement.attr("stroke"))
                            .attr("stroke-width", cityElement.attr("stroke-width"))
                            .attr("class", "city")  // Add CSS class for consistent styling
                            .style("stroke", cityElement.style("stroke") || "#333")  // Ensure stroke color
                            .style("stroke-width", cityElement.style("stroke-width") || "0.1");  // Ensure stroke width
                        
                        
                        // Animate the movement with custom interpolation
                        const startTime = Date.now();
                        const animateMovement = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / 3000, 1); // 2 second duration
                            
                            if (progress < 1) {
                                // Apply easing function for smoother movement
                                const easedProgress = d3.easeCubicInOut(progress);
                                
                                // Interpolate position with easing
                                const currentX = sourceCentroid[0] + (targetCentroid[0] - sourceCentroid[0]) * easedProgress;
                                const currentY = sourceCentroid[1] + (targetCentroid[1] - sourceCentroid[1]) * easedProgress;
                                
                                // Update moving group position
                                movingGroup.attr("transform", `translate(${currentX - sourceCentroid[0]}, ${currentY - sourceCentroid[1]})`);
                                
                                // Update merge line start point to follow the moving city
                                if (!mergeLine.empty()) {
                                    mergeLine.attr("x1", currentX)
                                             .attr("y1", currentY);
                                }
                                
                                requestAnimationFrame(animateMovement);
                            } else {
                                // Animation complete - ensure final position is exact
                                movingGroup.attr("transform", `translate(${targetCentroid[0] - sourceCentroid[0]}, ${targetCentroid[1] - sourceCentroid[1]})`);
                                
                                // Update merge line to final position
                                if (!mergeLine.empty()) {
                                    mergeLine.attr("x1", targetCentroid[0])
                                             .attr("y1", targetCentroid[1]);
                                }
                                
                                // Remove elements after a brief delay
                                setTimeout(() => {
                                    movingGroup.style("opacity", 0).remove();
                                }, 100);
                            }
                        };
                        
                        animateMovement();
                    }
                } else {
                    // Target city doesn't exist or was filtered out
                    console.warn(`Target city with ID ${mergedTo} not found in filtered data for source city ${sourceCity.properties.Agglomeration_Name} (ID: ${sourceId}), skipping merge animation`);
                }
            });
        }
        
        function animateSingleMerge(mergeData) {
            const sourceCity = mergeData.source;
            const targetCity = mergeData.target;
            const sourceId = mergeData.sourceId;
            const targetId = mergeData.targetId;
            
            // Validate that both cities have valid coordinates
            const sourceCentroid = path.centroid(sourceCity);
            const targetCentroid = path.centroid(targetCity);
            
            if (isNaN(sourceCentroid[0]) || isNaN(sourceCentroid[1])) {
                console.warn(`Source city ${sourceCity.properties.Agglomeration_Name} has invalid coordinates, skipping merge animation`);
                return;
            }
            
            if (isNaN(targetCentroid[0]) || isNaN(targetCentroid[1])) {
                console.warn(`Target city ${targetCity.properties.Agglomeration_Name} has invalid coordinates, skipping merge animation`);
                return;
            }
            
            // Find the corresponding 2025 city element
            const cityElement = g.selectAll(".city-2025")
                .filter(function(d) {
                    return d.properties.Agglomeration_ID === sourceId;
                });
            
            if (!cityElement.empty()) {
                // Hide the original city immediately
                cityElement.style("opacity", 0);
                
                // Find the corresponding merge line for this test case
                const mergeLine = g.selectAll(".merge-line")
                    .filter(function(d) {
                        return d.sourceId === sourceId && d.targetId === targetId;
                    });
                
                // Create a temporary group for the moving city
                const movingGroup = g.append("g")
                    .attr("class", "moving-city")
                    .style("opacity", 1);
                
                // Clone the city path to the moving group with complete styling
                const cityPath = cityElement.attr("d");
                movingGroup.append("path")
                    .attr("d", cityPath)
                    .attr("fill", cityElement.attr("fill"))
                    .attr("stroke", cityElement.attr("stroke"))
                    .attr("stroke-width", cityElement.attr("stroke-width"))
                    .attr("class", "city")  // Add CSS class for consistent styling
                    .style("stroke", cityElement.style("stroke") || "#333")  // Ensure stroke color
                    .style("stroke-width", cityElement.style("stroke-width") || "0.1");  // Ensure stroke width
                
                
                // Animate the movement with custom interpolation
                const startTime = Date.now();
                const animateMovement = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / 2000, 1); // 2 second duration for test
                    
                    if (progress < 1) {
                        // Apply easing function for smoother movement
                        const easedProgress = d3.easeCubicInOut(progress);
                        
                        // Interpolate position with easing
                        const currentX = sourceCentroid[0] + (targetCentroid[0] - sourceCentroid[0]) * easedProgress;
                        const currentY = sourceCentroid[1] + (targetCentroid[1] - sourceCentroid[1]) * easedProgress;
                        
                        // Update moving group position
                        movingGroup.attr("transform", `translate(${currentX - sourceCentroid[0]}, ${currentY - sourceCentroid[1]})`);
                        
                        // Update merge line start point to follow the moving city
                        if (!mergeLine.empty()) {
                            mergeLine.attr("x1", currentX)
                                     .attr("y1", currentY);
                        }
                        
                        requestAnimationFrame(animateMovement);
                    } else {
                        // Animation complete
                        movingGroup.attr("transform", `translate(${targetCentroid[0] - sourceCentroid[0]}, ${targetCentroid[1] - sourceCentroid[1]})`);
                        
                        // Update merge line to final position
                        if (!mergeLine.empty()) {
                            mergeLine.attr("x1", targetCentroid[0])
                                     .attr("y1", targetCentroid[1]);
                        }
                        
                        // Remove elements after a brief delay
                        setTimeout(() => {
                            movingGroup.style("opacity", 0).remove();
                        }, 1000);
                    }
                };
                
                animateMovement();
            }
        }

        function togglePlayPause() {
            isPlaying = !isPlaying;
            const button = d3.select("#playPause");
            
            if (isPlaying) {
                button.text("⏸ Pause").classed("active", true);
                startAnimation();
            } else {
                button.text("▶ Play").classed("active", false);
                stopAnimation();
            }
        }

        function resetAnimation() {
            stopAnimation();
            currentYear = "2025";
            currentData = data2025;
            updateYearDisplay();
            renderMap();
            
            // Restart animation if it was playing
            if (isPlaying) {
                startAnimation();
            }
        }



        // Load GeoJSON datasets
        Promise.all([
            d3.json("2025_4326.geojson"),
            d3.json("2050_4326.geojson")
        ]).then(function([data25, data50]) {
            // Filter data for West Africa only
            data2025 = filterWestAfrica(data25);
            data2050 = filterWestAfrica(data50);
            currentData = data2025;
            
            
            // Initial render
            updateYearDisplay();
            renderMap();
            
            // Set initial state for first transition
            g.selectAll(".city-2025").style("opacity", 1);
            g.selectAll(".city-2050").style("opacity", 0);
            
            // Start automatic animation
            startAnimation();
            
            // Add button event listeners
            d3.select("#playPause").on("click", togglePlayPause);
            d3.select("#resetAnimation").on("click", resetAnimation);
            
            // Add zoom button event listeners with adjusted scaling
            d3.select("#zoomIn").on("click", function() {
                svg.transition().call(zoom.scaleBy, 1.8); // Slightly larger zoom step
            });
            
            d3.select("#zoomOut").on("click", function() {
                svg.transition().call(zoom.scaleBy, 1 / 1.8); // Matching zoom out step
            });
            
            d3.select("#resetZoom").on("click", function() {
                // Reset to Lagos view - calculate the correct transform for Lagos position
                // Lagos is at longitude 3.4, latitude 6.5
                // We need to calculate where Lagos appears on the screen with current projection
                const lagosPoint = projection([3.4, 6.5]); // Get Lagos position in screen coordinates
                const lagosTransform = d3.zoomIdentity
                    .translate(width / 2 - lagosPoint[0], height / 2 - lagosPoint[1])
                    .scale(1);
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, lagosTransform);
            });
            
            // Add close button for info panel
            d3.select("#close-info").on("click", function() {
                d3.select("#info-panel").style("display", "none");
            });
            
        }).catch(function(error) {
            // Error loading GeoJSON
        });


        function showCityInfo(cityData) {
            const agglomerationId = cityData.properties.Agglomeration_ID;
            const props = cityData.properties;
            
            let info = `
                <strong>${props.Agglomeration_Name}</strong><br>
                <strong>Agglomeration ID:</strong> ${agglomerationId}<br>
                <strong>FID:</strong> ${props.fid}<br>
                <strong>Country:</strong> ${props.ISO3}<br>
                <strong>Coordinates:</strong> ${props.Longitude}, ${props.Latitude}<br>
            `;
            
            // Population data for all years
            info += `<br><strong>Population Data:</strong><br>`;
            const years = ['1950', '1960', '1970', '1980', '1990', '2000', '2010', '2015', '2020', '2025', '2030', '2035', '2040', '2045', '2050'];
            years.forEach(year => {
                const pop = props[`Population_${year}`];
                if (pop && pop > 0) {
                    const style = year === currentYear ? 'color: blue; font-weight: bold;' : '';
                    info += `<span style="${style}">${year}: ${pop.toLocaleString()}</span><br>`;
                }
            });
            
            // Built up area data
            info += `<br><strong>Built Up Area:</strong><br>`;
            const builtYears = ['2015', '2020', '2025', '2030', '2035', '2040', '2045', '2050'];
            builtYears.forEach(year => {
                const built = props[`Built_up_${year}`];
                if (built && built > 0) {
                    const style = year === currentYear ? 'color: blue; font-weight: bold;' : '';
                    info += `<span style="${style}">${year}: ${built}</span><br>`;
                }
            });
            
            // Voronoi data
            info += `<br><strong>Voronoi Area:</strong><br>`;
            builtYears.forEach(year => {
                const voronoi = props[`Voronoi_${year}`];
                if (voronoi && voronoi > 0) {
                    const style = year === currentYear ? 'color: blue; font-weight: bold;' : '';
                    info += `<span style="${style}">${year}: ${voronoi}</span><br>`;
                }
            });
            
            
            // Closest metro
            const closestMetro = props[`Closest Metro_${currentYear}`];
            if (closestMetro) {
                info += `<br><strong>Closest Metro ${currentYear}:</strong> ${closestMetro}<br>`;
            }
            
            // Distance to metro
            const distToMetro = props[`Dist to Metro_${currentYear}`];
            if (distToMetro && distToMetro > 0) {
                info += `<strong>Distance to Metro ${currentYear}:</strong> ${distToMetro} km<br>`;
            }
            
            // Metropole status
            if (props.Metropole) {
                info += `<br><strong>Metropole:</strong> ${props.Metropole}<br>`;
            }
            
            // MergedTo information
            if (props.MergedTo !== undefined && props.MergedTo !== null) {
                if (props.MergedTo > 0) {
                    info += `<br><strong>Merged To:</strong> ${props.MergedTo}<br>`;
                } else {
                    info += `<br><strong>Merged To:</strong> None (Independent city)<br>`;
                }
            }
            
            // DisaggFrom information
            if (props.DisaggFrom !== undefined && props.DisaggFrom !== null && props.DisaggFrom > 0) {
                info += `<br><strong>Disaggregated From:</strong> ${props.DisaggFrom}<br>`;
            }
            
            // Select Geometry Year
            if (props.Select_Geometry_Year) {
                info += `<br><strong>Geometry Year:</strong> ${props.Select_Geometry_Year}<br>`;
            }
            
            // Additional fields that might be useful
            const additionalFields = [
                'City_Type', 'Status', 'Classification', 'Urban_Type', 
                'City_Size', 'Development_Status', 'Growth_Rate'
            ];
            
            additionalFields.forEach(field => {
                if (props[field] !== undefined && props[field] !== null && props[field] !== '') {
                    info += `<br><strong>${field.replace(/_/g, ' ')}:</strong> ${props[field]}<br>`;
                }
            });
            
            // Screen coordinates for debugging
            const coords = path.centroid(cityData);
            info += `<br><strong>Screen coords:</strong> (${coords[0].toFixed(1)}, ${coords[1].toFixed(1)})<br>`;
            
            d3.select("#info-content").html(info);
            d3.select("#info-panel").style("display", "block");
        }

        function renderMap() {
            // Clear existing elements
            g.selectAll(".city").remove();
            g.selectAll(".merge-line").remove();
            
            // Use dynamic area filtering based on zoom level to prevent giant shapes
            const zoomLevel = d3.zoomTransform(svg.node()).k || 1;
            const baseThreshold = 100000;
            const dynamicThreshold = baseThreshold * Math.pow(2, Math.max(0, Math.log2(zoomLevel) - 2)); // Adjust based on zoom level
            
            const filteredData2025 = data2025.features.filter(function(d) {
                const bounds = path.bounds(d);
                const area = (bounds[1][0] - bounds[0][0]) * (bounds[1][1] - bounds[0][1]);
                return area < dynamicThreshold;
            });
            
            const filteredData2050 = data2050.features.filter(function(d) {
                const bounds = path.bounds(d);
                const area = (bounds[1][0] - bounds[0][0]) * (bounds[1][1] - bounds[0][1]);
                return area < dynamicThreshold;
            });
            
            
            // Draw 2025 cities
            const cities2025 = g.selectAll(".city-2025")
                .data(filteredData2025, function(d) { 
                    return "2025-" + d.properties.Agglomeration_ID;
                });

            cities2025.enter()
                .append("path")
                .attr("class", "city city-2025")
                .attr("d", path)
                .attr("fill", function(d) {
                    const population = d.properties.Population_2025;
                    if (!population || population <= 0) {
                        return "#e0e0e0";
                    }
                    return colorScale(population);
                })
                .attr("title", function(d) {
                    return d.properties.Agglomeration_Name + " (2025) - Population: " + 
                           (d.properties.Population_2025?.toLocaleString() || "N/A");
                })
                .on("click", function(event, d) {
                    event.stopPropagation();
                    showCityInfo(d);
                })
                .style("opacity", currentYear === "2025" ? 1 : 0);

            // Draw 2050 cities
            const cities2050 = g.selectAll(".city-2050")
                .data(filteredData2050, function(d) { 
                    return "2050-" + d.properties.Agglomeration_ID;
                });

            cities2050.enter()
                .append("path")
                .attr("class", "city city-2050")
                .attr("d", path)
                .attr("fill", function(d) {
                    const population = d.properties.Population_2050;
                    if (!population || population <= 0) {
                        return "#e0e0e0";
                    }
                    return colorScale(population);
                })
                .attr("title", function(d) {
                    return d.properties.Agglomeration_Name + " (2050) - Population: " + 
                           (d.properties.Population_2050?.toLocaleString() || "N/A");
                })
                .on("click", function(event, d) {
                    event.stopPropagation();
                    showCityInfo(d);
                })
                .style("opacity", currentYear === "2050" ? 1 : 0);

            // Draw merge lines FIRST (so they appear above cities)
            const mergeLines = [];
            
            // Find all merge relationships
            filteredData2025.forEach(sourceCity => {
                const sourceId = sourceCity.properties.Agglomeration_ID;
                const mergedTo = sourceCity.properties.MergedTo;
                
                // Check if this city merges to another city
                if (mergedTo && mergedTo > 0 && mergedTo !== sourceId) {
                    // Find the target city
                    const targetCity = filteredData2025.find(city => 
                        city.properties.Agglomeration_ID === mergedTo
                    );
                    
                    if (targetCity) {
                        mergeLines.push({
                            source: sourceCity,
                            target: targetCity,
                            sourceId: sourceId,
                            targetId: mergedTo
                        });
                    }
                }
            });
            
            
            // Draw the merge lines
            const lines = g.selectAll(".merge-line")
                .data(mergeLines, d => `${d.sourceId}-${d.targetId}`);

            lines.enter()
                .append("line")
                .attr("class", "merge-line")
                .attr("x1", d => path.centroid(d.source)[0])
                .attr("y1", d => path.centroid(d.source)[1])
                .attr("x2", d => path.centroid(d.target)[0])
                .attr("y2", d => path.centroid(d.target)[1])
                .attr("stroke", "red")
                .attr("stroke-width", 0.6)
                .attr("stroke-dasharray", "1.5,1.5")
                .each(function() {
                    const line = d3.select(this);
                    let offset = 0;
                    let lastTime = 0;
                    const targetFPS = 60; // 目标帧率
                    const frameInterval = 1000 / targetFPS; // 每帧间隔时间
                    
                    const animate = function(currentTime) {
                        // 确保动画以恒定速度运行，不受其他动画影响
                        if (currentTime - lastTime >= frameInterval) {
                            offset = (offset + 0.1) % 10;
                            line.attr("stroke-dashoffset", -offset);
                            lastTime = currentTime;
                        }
                        
                        // 使用 setTimeout 而不是 requestAnimationFrame 来避免被其他动画阻塞
                        setTimeout(() => {
                            if (line.node().parentNode) { // 检查元素是否还存在
                                animate(performance.now());
                            }
                        }, 16); // 约60fps
                    };
                    
                    // Start animation only if not already running
                    if (!line.node()._animationRunning) {
                        line.node()._animationRunning = true;
                        animate(performance.now());
                    }
                });

            lines.exit().remove();
            
            // Update opacity for all lines (both new and existing) - always visible, no transition
            g.selectAll(".merge-line")
                .style("opacity", 0.5);  // 线条始终可见，不跟随年份变化，不影响动画速度

            // Update opacity for existing cities based on current year
            g.selectAll(".city-2025")
                .style("opacity", currentYear === "2025" ? 1 : 0);
            
            g.selectAll(".city-2050")
                .style("opacity", currentYear === "2050" ? 1 : 0);
        }
    </script>
    </div>
</body>
</html>
