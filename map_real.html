<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2050 Population Map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: #e9ecef;
            overflow: hidden;
        }
        body {
            padding: 15px;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            padding: 15px;
            max-width: 100%;
            height: calc(100vh - 60px);
            display: flex;
            flex-direction: column;
        }
        #map {
            width: 100%;
            flex: 1;
            border: 1px solid #ddd;
            background: #fff;
            margin: 5px 0;
            position: relative;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 0;
            user-select: none; /* Disable text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            outline: none; /* Remove focus outline */
        }
        .leaflet-container {
            height: 100%;
            width: 100%;
            user-select: none; /* Disable text selection */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            outline: none; /* Remove focus outline */
        }
        .d3-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }
        .d3-overlay svg {
            pointer-events: none; /* Allow mouse events to pass through to Leaflet */
        }
        .d3-overlay svg .city {
            pointer-events: all; /* Enable mouse events for city elements */
        }
        .d3-overlay svg .merge-line {
            pointer-events: all; /* Enable mouse events for merge lines */
        }
        .moving-city {
            will-change: transform;
            backface-visibility: hidden;
            transform-style: preserve-3d;
        }
        /* Disable selection and focus outlines for all interactive elements */
        * {
            -webkit-tap-highlight-color: transparent;
        }
        .leaflet-container:focus,
        .leaflet-container:active,
        #map:focus,
        #map:active {
            outline: none !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1) !important;
        }
        .city {
            stroke: #333;
            stroke-width: 0.2;
            vector-effect: non-scaling-stroke;
            stroke-opacity: 0.8;
        }
        .city:hover {
            fill: rgba(255, 107, 107, 0);
            stroke: #ff6b6b;
            stroke-width: 0.3;
            vector-effect: non-scaling-stroke;
            stroke-opacity: 0.9;
        }
        #controls {
            text-align: center;
            margin: 5px 0;
            padding: 6px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        .year-btn {
            padding: 4px 8px;
            margin: 0 2px;
            font-size: 11px;
            border: 1px solid #ccc;
            background: #f8f9fa;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s ease;
            color: #666;
        }
        .year-btn.active {
            background: #333;
            color: white;
            border-color: #333;
        }
        .year-btn:hover {
            background: #e9ecef;
            border-color: #999;
        }
        .map-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            display: flex;
            gap: 8px;
        }
        .zoom-controls {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .pan-controls {
            display: block;
        }
        .pan-row {
            display: flex;
            justify-content: center;
            margin: 1px 0;
        }
        .control-btn {
            width: 28px;
            height: 28px;
            margin: 0;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid #ccc;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            color: #333;
        }
        .control-btn:hover {
            background: #f0f0f0;
            border-color: #999;
            transform: scale(1.05);
        }
        .control-btn:active {
            transform: scale(0.95);
            background: #e0e0e0;
        }
        #legend {
            margin: 5px auto;
            max-width: 100%;
            padding: 6px 12px;
            background: white;
            border-radius: 6px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        .legend-item {
            display: inline-block;
            margin: 0;
        }
        .legend-color {
            display: inline-block;
            width: 16px;
            height: 12px;
            margin-right: 6px;
            border: 1px solid #333;
            vertical-align: middle;
        }
        .legend-line {
            display: inline-block;
            width: 16px;
            height: 2px;
            margin-right: 6px;
            background: red;
            vertical-align: middle;
        }
        .animation-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
            justify-content: center;
        }
        .year-indicator {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 4px 8px;
            border-radius: 3px;
            font-weight: bold;
            font-size: 11px;
            color: #495057;
            display: inline-block;
            margin: 0 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="font-size: 16px; margin: 2px 0; color: #333; font-weight: 500; flex-shrink: 0;">West Africa Agglomeration Growth 2025-2050</h1>
        <div id="controls">
            <div class="animation-controls">
                <button id="playPause" class="year-btn active">⏸ Pause</button>
                <button id="resetAnimation" class="year-btn">Reset</button>
                <div class="year-indicator">
                    <span id="currentYearDisplay">2025</span>
                </div>
                <span style="font-size: 12px; font-weight: 500; color: #666; margin-left: 15px;">Population:</span>
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <div class="legend-gradient" style="background: linear-gradient(to right, #E4E3BE, #8E4728); height: 12px; width: 120px; border: 1px solid #ccc; border-radius: 2px;"></div>
                    <div style="display: flex; justify-content: space-between; width: 120px; font-size: 10px; color: #666;">
                        <span>1K</span>
                        <span>50M</span>
                    </div>
                </div>
                <div style="display: flex; align-items: center; margin-left: 10px;">
                    <div style="width: 16px; height: 2px; background: repeating-linear-gradient(to right, #ff6b6b 0px, #ff6b6b 3px, transparent 3px, transparent 6px); margin-right: 6px;"></div>
                    <span style="font-size: 10px; color: #666;">Merge flow</span>
                </div>
            </div>
        </div>
        <div id="map">
        <div id="leaflet-map"></div>
        <div class="d3-overlay" id="d3-overlay"></div>
        <div class="map-controls">
            <div class="zoom-controls">
                <button id="zoomIn" class="control-btn">+</button>
                <button id="zoomOut" class="control-btn">−</button>
                <button id="resetZoom" class="control-btn">⌂</button>
            </div>
            <div class="pan-controls">
                <div class="pan-row">
                    <button id="panUp" class="control-btn">↑</button>
                </div>
                <div class="pan-row">
                    <button id="panLeft" class="control-btn">←</button>
                    <button id="panRight" class="control-btn">→</button>
                </div>
                <div class="pan-row">
                    <button id="panDown" class="control-btn">↓</button>
                </div>
            </div>
        </div>
    </div>
    <div id="info-panel" style="position: fixed; top: 10px; right: 10px; background: white; border: 1px solid #ccc; padding: 10px; max-width: 400px; max-height: 80vh; overflow-y: auto; display: none; z-index: 1000; font-size: 12px;">
        <h4>City Info</h4>
        <div id="info-content"></div>
        <button id="close-info" style="margin-top: 10px;">Close</button>
    </div>

    <script>
        // Initialize Leaflet map
        const map = L.map('leaflet-map', {
            zoomControl: false, // We'll use our custom zoom controls
            scrollWheelZoom: true, // Enable mouse wheel zoom
            dragging: true, // Enable mouse drag pan
            doubleClickZoom: true, // Enable double-click zoom
            boxZoom: true, // Enable box zoom
            keyboard: true, // Enable keyboard navigation
            touchZoom: true, // Enable touch zoom
            bounceAtZoomLimits: true // Bounce effect at zoom limits
        }).setView([6.5, 3.4], 8); // Focus on Lagos coastal area

        // Add minimal EPSG:4326 base map
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            attribution: '© OpenStreetMap contributors © CARTO',
            subdomains: 'abcd',
            maxZoom: 20,
            crs: L.CRS.EPSG4326
        }).addTo(map);

        // Set up D3 overlay - dynamic sizing
        const svg = d3.select("#d3-overlay")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("preserveAspectRatio", "xMidYMid meet");

        // Create a group for all map elements
        const g = svg.append("g");

        // Create projection for EPSG:4326
        const projection = d3.geoEquirectangular()
            .scale(1)
            .translate([0, 0]);

        const path = d3.geoPath().projection(projection);

        // Function to convert lat/lng to pixel coordinates
        function latLngToPoint(lat, lng) {
            const point = map.latLngToContainerPoint([lat, lng]);
            return [point.x, point.y];
        }

        // Function to convert pixel coordinates to lat/lng
        function pointToLatLng(x, y) {
            return map.containerPointToLatLng([x, y]);
        }

        // Remove D3 zoom behavior to avoid conflicts with Leaflet
        // Leaflet will handle all zoom and pan operations

        // Update D3 projection to match Leaflet's current view
        function updateProjection() {
            // Only update if data is loaded and not currently animating
            if (!data2025 || !data2050 || isAnimating) return;
            
            const mapSize = map.getSize();
            const zoomLevel = map.getZoom();
            
            // Update SVG viewBox to match map container size
            svg.attr("viewBox", `0 0 ${mapSize.x} ${mapSize.y}`);
            
            // Create a custom projection that uses Leaflet's coordinate conversion
            const customProjection = {
                stream: function(stream) {
                    return {
                        point: function(x, y) {
                            // Convert from longitude/latitude to Leaflet's container coordinates
                            const latLng = [y, x]; // Note: Leaflet uses [lat, lng] format
                            const point = map.latLngToContainerPoint(latLng);
                            stream.point(point.x, point.y);
                        },
                        lineStart: function() { stream.lineStart(); },
                        lineEnd: function() { stream.lineEnd(); },
                        polygonStart: function() { stream.polygonStart(); },
                        polygonEnd: function() { stream.polygonEnd(); }
                    };
                }
            };
            
            // Update the path generator to use our custom projection
            path.projection(customProjection);
            
            // Calculate stroke width based on zoom level for better visibility
            const baseStrokeWidth = 0.2;
            const baseLineWidth = 0.8;
            const zoomFactor = Math.pow(1.3, Math.max(0, zoomLevel - 8)); // More gradual scaling
            const adjustedStrokeWidth = Math.max(0.2, Math.min(1.5, baseStrokeWidth * zoomFactor));
            const adjustedLineWidth = Math.max(0.8, Math.min(2.5, baseLineWidth * zoomFactor));
            
            // Update stroke widths for existing elements
            g.selectAll(".city")
                .style("stroke-width", adjustedStrokeWidth);
            
            g.selectAll(".merge-line")
                .style("stroke-width", adjustedLineWidth);
            
            renderMap();
        }

        // Listen for map view changes (but not during animation)
        map.on('viewreset', function() {
            if (!isAnimating) updateProjection();
        });
        map.on('zoom', function() {
            if (!isAnimating) updateProjection();
        });
        map.on('move', function() {
            if (!isAnimating) updateProjection();
        });
        map.on('resize', function() {
            if (!isAnimating) updateProjection();
        });
        
        // Listen for window resize
        window.addEventListener('resize', function() {
            setTimeout(updateProjection, 100); // Small delay to ensure map has resized
        });
        
        // Add keyboard shortcuts for better interaction
        document.addEventListener('keydown', function(e) {
            // Prevent default behavior for zoom keys
            if (e.ctrlKey || e.metaKey) {
                if (e.key === '+' || e.key === '=') {
                    e.preventDefault();
                    map.zoomIn();
                } else if (e.key === '-') {
                    e.preventDefault();
                    map.zoomOut();
                } else if (e.key === '0') {
                    e.preventDefault();
                    map.setView([6.5, 3.4], 8); // Reset to original view
                }
            }
            
            // Arrow keys for panning
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat + 0.5, currentCenter.lng], map.getZoom());
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat - 0.5, currentCenter.lng], map.getZoom());
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat, currentCenter.lng - 0.5], map.getZoom());
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat, currentCenter.lng + 0.5], map.getZoom());
            }
        });

        svg.on("click", function() {
            // Click on empty space to close info panel
            d3.select("#info-panel").style("display", "none");
        });

        // Create continuous color scale
        const colorScale = d3.scaleLinear()
            .domain([1000, 50000000]) // Population range
            .range(["#E4E3BE", "#8E4728"]); // Light beige to dark brown

        // West African countries (ISO3 codes)
        const westAfricanCountries = [
            'BEN', 'BFA', 'CPV', 'CIV', 'GMB', 'GHA', 'GIN', 'GNB', 'LBR', 
            'MLI', 'MRT', 'NER', 'NGA', 'SEN', 'SLE', 'TGO'
        ];

        let currentYear = "2025";
        let data2025 = null;
        let data2050 = null;
        let currentData = null;
        
        // Animation variables
        let isPlaying = true;
        let animationInterval = null;
        let animationSpeed = 5500; // seconds between transitions
        let lastTransitionTime = 0;
        let currentPhase = "2025_display"; // 2025_display, 2025_to_2050, 2050_display, 2050_to_2025
        let isAnimating = false; // Flag to prevent projection updates during animation

        // Function to filter data for West Africa only
        function filterWestAfrica(data) {
            if (!data || !data.features) return data;
            
            const filteredFeatures = data.features.filter(feature => {
                const iso3 = feature.properties.ISO3;
                return westAfricanCountries.includes(iso3);
            });
            
            return {
                ...data,
                features: filteredFeatures
            };
        }

        // Animation control functions
        function startAnimation() {
            if (animationInterval) return;
            
            animationInterval = setInterval(() => {
                if (isPlaying) {
                    switchYear();
                }
            }, animationSpeed);
        }

        function stopAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        function switchYear() {
            if (currentYear === "2025") {
                // Transition from 2025 to 2050 with smooth animation
                currentYear = "2050";
                updateYearDisplay();
                
                // Debug: Log animation trigger
                console.log("Switching to 2050, triggering merge animation");
                
                // First: Animate merging cities moving to their target cities (1 second)
                isAnimating = true; // Set flag to prevent projection updates during animation
                animateMergingCities();
                
                // Then: Update opacity for both year groups with smooth transitions (1.5 seconds for both)
                // Use a delay to start after the movement animation is completely finished
                setTimeout(() => {
                    // 对于2025年城市：只对非合并城市进行淡出，合并城市保持隐藏状态
                    g.selectAll(".city-2025")
                        .filter(function(d) {
                            // 只对非合并城市进行淡出动画
                            const mergedTo = d.properties.MergedTo;
                            return !mergedTo || mergedTo <= 0 || mergedTo === d.properties.Agglomeration_ID;
                        })
                        .style("opacity", 1)  // 确保从可见状态开始
                        .transition()
                        .duration(300)  // 2025年渐隐：0.3秒
                        .ease(d3.easeLinear)  // 使用线性缓动，减少计算负担
                        .style("opacity", 0);
                    
                    // 合并的城市保持隐藏状态，不进行淡出动画
                    g.selectAll(".city-2025")
                        .filter(function(d) {
                            const mergedTo = d.properties.MergedTo;
                            return mergedTo && mergedTo > 0 && mergedTo !== d.properties.Agglomeration_ID;
                        })
                        .style("opacity", 0);  // 保持隐藏状态
                    
                    g.selectAll(".city-2050")
                        .style("opacity", 0)  // 确保从不可见状态开始
                        .transition()
                        .duration(300)  // 2050年渐显：0.3秒（与2025年渐隐同步）
                        .ease(d3.easeLinear)  // 使用线性缓动，减少计算负担
                        .style("opacity", 1);
                    
                    // 在2050年完全显示后，重新渲染地图并重置线条位置
                    setTimeout(() => {
                        // Re-render map to ensure merge lines exist for 2050 and reset to original positions
                        isAnimating = false; // Clear animation flag
                        updateProjection(); // This will call renderMap() internally
                    }, 300); // 等待2050年完全显示后再重置线条
                }, 3200); // 延迟3.2秒，确保移动动画完全完成
                
                // Keep merge lines visible during 2025→2050 transition (they maintain shifted positions)
                g.selectAll(".merge-line")
                    .style("opacity", 0.5);  // 线条保持可见，保持移位位置
                    
            } else {
                // Cross-fade from 2050 to 2025: 2025 fades out while 2050 fades in
                currentYear = "2025";
                updateYearDisplay();
                
                // Re-render map to recreate merge lines
                updateProjection(); // This will call renderMap() internally
                
                // 2050年直接消失，2025年直接出现（无过渡）
                g.selectAll(".city-2050")
                    .style("opacity", 0);  // 2050年直接消失
                
                g.selectAll(".city-2025")
                    .style("opacity", 1);  // 2025年直接出现
                
                // Merge lines fade in (3 seconds) - but don't affect animation speed
                g.selectAll(".merge-line")
                    .style("opacity", 0.5);  // 2025年时线条更明显，不影响动画速度
            }
        }

        function updateYearDisplay() {
            d3.select("#currentYearDisplay").text(currentYear);
        }
        
        function animateMergingCities() {
            // Use all data without area filtering to prevent cities from disappearing when zoomed
            const filteredData2025 = data2025.features;
            
            // Find all cities that will be merged (only from filtered data)
            const mergingCities = filteredData2025.filter(city => {
                const mergedTo = city.properties.MergedTo;
                return mergedTo && mergedTo > 0 && mergedTo !== city.properties.Agglomeration_ID;
            });
            
            // Debug: Log merging cities
            console.log("Found merging cities:", mergingCities.length);
            if (mergingCities.length > 0) {
                console.log("First merging city:", mergingCities[0].properties.Agglomeration_Name, "merges to:", mergingCities[0].properties.MergedTo);
            }
            
            // If no merging cities found, create a test case
            if (mergingCities.length === 0) {
                console.log("No merging cities found, creating test case");
                // Find two cities to create a test merge
                const testCities = filteredData2025.slice(0, 2);
                if (testCities.length >= 2) {
                    // Create a test merge
                    const testMerge = {
                        source: testCities[0],
                        target: testCities[1],
                        sourceId: testCities[0].properties.Agglomeration_ID,
                        targetId: testCities[1].properties.Agglomeration_ID
                    };
                    console.log("Creating test merge from", testMerge.source.properties.Agglomeration_Name, "to", testMerge.target.properties.Agglomeration_Name);
                    animateSingleMerge(testMerge);
                }
                return;
            }
            
            mergingCities.forEach(sourceCity => {
                const sourceId = sourceCity.properties.Agglomeration_ID;
                const mergedTo = sourceCity.properties.MergedTo;
                
                // Find the target city in the filtered data
                const targetCity = filteredData2025.find(city => 
                    city.properties.Agglomeration_ID === mergedTo
                );
                
                // Validate that target city exists and is not filtered out
                if (targetCity) {
                    // Pre-calculate centroids to avoid repeated coordinate conversion
                    const sourceCentroid = path.centroid(sourceCity);
                    const targetCentroid = path.centroid(targetCity);
                    
                    if (isNaN(targetCentroid[0]) || isNaN(targetCentroid[1])) {
                        console.warn(`Target city ${targetCity.properties.Agglomeration_Name} (ID: ${mergedTo}) has invalid coordinates, skipping merge animation`);
                        return;
                    }
                    
                    // Find the corresponding 2025 city element
                    const cityElement = g.selectAll(".city-2025")
                        .filter(function(d) {
                            return d.properties.Agglomeration_ID === sourceId;
                        });
                    
                    // Find the corresponding merge line
                    const mergeLine = g.selectAll(".merge-line")
                        .filter(function(d) {
                            return d.sourceId === sourceId && d.targetId === mergedTo;
                        });
                    
                    if (!cityElement.empty()) {
                        // Hide the original city immediately
                        cityElement.style("opacity", 0);
                        
                        // Create a temporary group for the moving city
                        const movingGroup = g.append("g")
                            .attr("class", "moving-city")
                            .style("opacity", 1);
                        
                        // Clone the city path to the moving group with complete styling
                        const cityPath = cityElement.attr("d");
                        movingGroup.append("path")
                            .attr("d", cityPath)
                            .attr("fill", cityElement.attr("fill"))
                            .attr("stroke", cityElement.attr("stroke"))
                            .attr("stroke-width", cityElement.attr("stroke-width"))
                            .attr("class", "city")  // Add CSS class for consistent styling
                            .style("stroke", cityElement.style("stroke") || "#333")  // Ensure stroke color
                            .style("stroke-width", cityElement.style("stroke-width") || "0.1");  // Ensure stroke width
                        
                        // Use D3's built-in transition for smoother animation
                        const duration = 3000; // 3 seconds
                        
                        // Calculate the final transform values
                        const deltaX = targetCentroid[0] - sourceCentroid[0];
                        const deltaY = targetCentroid[1] - sourceCentroid[1];
                        
                        // Set initial position and disable pointer events during animation
                        movingGroup.attr("transform", `translate(0, 0)`)
                                  .style("pointer-events", "none");
                        
                        // Use D3 transition for smooth animation with optimized settings
                        movingGroup.transition()
                            .duration(duration)
                            .ease(d3.easeCubicInOut)
                            .attr("transform", `translate(${deltaX}, ${deltaY})`)
                            .on("start", function() {
                                // Ensure smooth rendering during animation
                                movingGroup.style("will-change", "transform");
                            })
                            .on("end", function() {
                                // Animation complete - ensure final position is exact
                                movingGroup.attr("transform", `translate(${deltaX}, ${deltaY})`)
                                          .style("will-change", "auto");
                                
                                // Update merge line to final position
                                if (!mergeLine.empty()) {
                                    mergeLine.attr("x1", targetCentroid[0])
                                             .attr("y1", targetCentroid[1]);
                                }
                                
                                // Remove elements after a brief delay
                                setTimeout(() => {
                                    movingGroup.style("opacity", 0).remove();
                                }, 100);
                            });
                        
                        // Animate merge line separately for smoother movement
                        if (!mergeLine.empty()) {
                            mergeLine.transition()
                                .duration(duration)
                                .ease(d3.easeCubicInOut)
                                .attr("x1", targetCentroid[0])
                                .attr("y1", targetCentroid[1]);
                        }
                    }
                } else {
                    // Target city doesn't exist or was filtered out
                    console.warn(`Target city with ID ${mergedTo} not found in filtered data for source city ${sourceCity.properties.Agglomeration_Name} (ID: ${sourceId}), skipping merge animation`);
                }
            });
        }
        
        function animateSingleMerge(mergeData) {
            const sourceCity = mergeData.source;
            const targetCity = mergeData.target;
            const sourceId = mergeData.sourceId;
            const targetId = mergeData.targetId;
            
            // Pre-calculate centroids to avoid repeated coordinate conversion
            const sourceCentroid = path.centroid(sourceCity);
            const targetCentroid = path.centroid(targetCity);
            
            if (isNaN(sourceCentroid[0]) || isNaN(sourceCentroid[1])) {
                console.warn(`Source city ${sourceCity.properties.Agglomeration_Name} has invalid coordinates, skipping merge animation`);
                return;
            }
            
            if (isNaN(targetCentroid[0]) || isNaN(targetCentroid[1])) {
                console.warn(`Target city ${targetCity.properties.Agglomeration_Name} has invalid coordinates, skipping merge animation`);
                return;
            }
            
            // Find the corresponding 2025 city element
            const cityElement = g.selectAll(".city-2025")
                .filter(function(d) {
                    return d.properties.Agglomeration_ID === sourceId;
                });
            
            if (!cityElement.empty()) {
                // Hide the original city immediately
                cityElement.style("opacity", 0);
                
                // Find the corresponding merge line for this test case
                const mergeLine = g.selectAll(".merge-line")
                    .filter(function(d) {
                        return d.sourceId === sourceId && d.targetId === targetId;
                    });
                
                // Create a temporary group for the moving city
                const movingGroup = g.append("g")
                    .attr("class", "moving-city")
                    .style("opacity", 1);
                
                // Clone the city path to the moving group with complete styling
                const cityPath = cityElement.attr("d");
                movingGroup.append("path")
                    .attr("d", cityPath)
                    .attr("fill", cityElement.attr("fill"))
                    .attr("stroke", cityElement.attr("stroke"))
                    .attr("stroke-width", cityElement.attr("stroke-width"))
                    .attr("class", "city")  // Add CSS class for consistent styling
                    .style("stroke", cityElement.style("stroke") || "#333")  // Ensure stroke color
                    .style("stroke-width", cityElement.style("stroke-width") || "0.1");  // Ensure stroke width
                
                // Use D3's built-in transition for smoother animation
                const duration = 2000; // 2 seconds for test
                
                // Calculate the final transform values
                const deltaX = targetCentroid[0] - sourceCentroid[0];
                const deltaY = targetCentroid[1] - sourceCentroid[1];
                
                // Set initial position and disable pointer events during animation
                movingGroup.attr("transform", `translate(0, 0)`)
                          .style("pointer-events", "none");
                
                // Use D3 transition for smooth animation with optimized settings
                movingGroup.transition()
                    .duration(duration)
                    .ease(d3.easeCubicInOut)
                    .attr("transform", `translate(${deltaX}, ${deltaY})`)
                    .on("start", function() {
                        // Ensure smooth rendering during animation
                        movingGroup.style("will-change", "transform");
                    })
                    .on("end", function() {
                        // Animation complete - ensure final position is exact
                        movingGroup.attr("transform", `translate(${deltaX}, ${deltaY})`)
                                  .style("will-change", "auto");
                        
                        // Update merge line to final position
                        if (!mergeLine.empty()) {
                            mergeLine.attr("x1", targetCentroid[0])
                                     .attr("y1", targetCentroid[1]);
                        }
                        
                        // Remove elements after a brief delay
                        setTimeout(() => {
                            movingGroup.style("opacity", 0).remove();
                        }, 1000);
                    });
                
                // Animate merge line separately for smoother movement
                if (!mergeLine.empty()) {
                    mergeLine.transition()
                        .duration(duration)
                        .ease(d3.easeCubicInOut)
                        .attr("x1", targetCentroid[0])
                        .attr("y1", targetCentroid[1]);
                }
            }
        }

        function togglePlayPause() {
            isPlaying = !isPlaying;
            const button = d3.select("#playPause");
            
            if (isPlaying) {
                button.text("⏸ Pause").classed("active", true);
                startAnimation();
            } else {
                button.text("▶ Play").classed("active", false);
                stopAnimation();
            }
        }

        function resetAnimation() {
            stopAnimation();
            currentYear = "2025";
            currentData = data2025;
            updateYearDisplay();
            updateProjection(); // This will call renderMap() internally
            
            // Restart animation if it was playing
            if (isPlaying) {
                startAnimation();
            }
        }



        // Load GeoJSON datasets
        Promise.all([
            d3.json("2025_4326.geojson"),
            d3.json("2050_4326.geojson")
        ]).then(function([data25, data50]) {
            // Filter data for West Africa only
            data2025 = filterWestAfrica(data25);
            data2050 = filterWestAfrica(data50);
            currentData = data2025;
            
            
            // Initial render
            updateYearDisplay();
            updateProjection(); // This will call renderMap() internally
            
            // Set initial state for first transition
            g.selectAll(".city-2025").style("opacity", 1);
            g.selectAll(".city-2050").style("opacity", 0);
            
            // Start automatic animation
            startAnimation();
            
            // Add button event listeners
            d3.select("#playPause").on("click", togglePlayPause);
            d3.select("#resetAnimation").on("click", resetAnimation);
            
            // Add map control button event listeners
            d3.select("#zoomIn").on("click", function() {
                map.zoomIn();
            });
            
            d3.select("#zoomOut").on("click", function() {
                map.zoomOut();
            });
            
            d3.select("#resetZoom").on("click", function() {
                map.setView([6.5, 3.4], 8);
            });
            
            d3.select("#panUp").on("click", function() {
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat + 2, currentCenter.lng], map.getZoom());
            });
            
            d3.select("#panDown").on("click", function() {
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat - 2, currentCenter.lng], map.getZoom());
            });
            
            d3.select("#panLeft").on("click", function() {
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat, currentCenter.lng - 2], map.getZoom());
            });
            
            d3.select("#panRight").on("click", function() {
                const currentCenter = map.getCenter();
                map.setView([currentCenter.lat, currentCenter.lng + 2], map.getZoom());
            });
            
            // Add close button for info panel
            d3.select("#close-info").on("click", function() {
                d3.select("#info-panel").style("display", "none");
            });
            
        }).catch(function(error) {
            // Error loading GeoJSON
        });


        function showCityInfo(cityData) {
            const agglomerationId = cityData.properties.Agglomeration_ID;
            const props = cityData.properties;
            
            let info = `
                <strong>${props.Agglomeration_Name}</strong><br>
                <strong>Agglomeration ID:</strong> ${agglomerationId}<br>
                <strong>FID:</strong> ${props.fid}<br>
                <strong>Country:</strong> ${props.ISO3}<br>
                <strong>Coordinates:</strong> ${props.Longitude}, ${props.Latitude}<br>
            `;
            
            // Population data for all years
            info += `<br><strong>Population Data:</strong><br>`;
            const years = ['1950', '1960', '1970', '1980', '1990', '2000', '2010', '2015', '2020', '2025', '2030', '2035', '2040', '2045', '2050'];
            years.forEach(year => {
                const pop = props[`Population_${year}`];
                if (pop && pop > 0) {
                    const style = year === currentYear ? 'color: blue; font-weight: bold;' : '';
                    info += `<span style="${style}">${year}: ${pop.toLocaleString()}</span><br>`;
                }
            });
            
            // Built up area data
            info += `<br><strong>Built Up Area:</strong><br>`;
            const builtYears = ['2015', '2020', '2025', '2030', '2035', '2040', '2045', '2050'];
            builtYears.forEach(year => {
                const built = props[`Built_up_${year}`];
                if (built && built > 0) {
                    const style = year === currentYear ? 'color: blue; font-weight: bold;' : '';
                    info += `<span style="${style}">${year}: ${built}</span><br>`;
                }
            });
            
            // Voronoi data
            info += `<br><strong>Voronoi Area:</strong><br>`;
            builtYears.forEach(year => {
                const voronoi = props[`Voronoi_${year}`];
                if (voronoi && voronoi > 0) {
                    const style = year === currentYear ? 'color: blue; font-weight: bold;' : '';
                    info += `<span style="${style}">${year}: ${voronoi}</span><br>`;
                }
            });
            
            
            // Closest metro
            const closestMetro = props[`Closest Metro_${currentYear}`];
            if (closestMetro) {
                info += `<br><strong>Closest Metro ${currentYear}:</strong> ${closestMetro}<br>`;
            }
            
            // Distance to metro
            const distToMetro = props[`Dist to Metro_${currentYear}`];
            if (distToMetro && distToMetro > 0) {
                info += `<strong>Distance to Metro ${currentYear}:</strong> ${distToMetro} km<br>`;
            }
            
            // Metropole status
            if (props.Metropole) {
                info += `<br><strong>Metropole:</strong> ${props.Metropole}<br>`;
            }
            
            // MergedTo information
            if (props.MergedTo !== undefined && props.MergedTo !== null) {
                if (props.MergedTo > 0) {
                    info += `<br><strong>Merged To:</strong> ${props.MergedTo}<br>`;
                } else {
                    info += `<br><strong>Merged To:</strong> None (Independent city)<br>`;
                }
            }
            
            // DisaggFrom information
            if (props.DisaggFrom !== undefined && props.DisaggFrom !== null && props.DisaggFrom > 0) {
                info += `<br><strong>Disaggregated From:</strong> ${props.DisaggFrom}<br>`;
            }
            
            // Select Geometry Year
            if (props.Select_Geometry_Year) {
                info += `<br><strong>Geometry Year:</strong> ${props.Select_Geometry_Year}<br>`;
            }
            
            // Additional fields that might be useful
            const additionalFields = [
                'City_Type', 'Status', 'Classification', 'Urban_Type', 
                'City_Size', 'Development_Status', 'Growth_Rate'
            ];
            
            additionalFields.forEach(field => {
                if (props[field] !== undefined && props[field] !== null && props[field] !== '') {
                    info += `<br><strong>${field.replace(/_/g, ' ')}:</strong> ${props[field]}<br>`;
                }
            });
            
            // Screen coordinates for debugging
            const coords = path.centroid(cityData);
            info += `<br><strong>Screen coords:</strong> (${coords[0].toFixed(1)}, ${coords[1].toFixed(1)})<br>`;
            
            d3.select("#info-content").html(info);
            d3.select("#info-panel").style("display", "block");
        }

        function renderMap() {
            // Clear existing elements
            g.selectAll(".city").remove();
            g.selectAll(".merge-line").remove();
            
            // Projection is already updated by updateProjection() - no need to recalculate
            
            // Use all data without area filtering to prevent cities from disappearing when zoomed
            // The area filtering was causing cities like Lagos to disappear at higher zoom levels
            const filteredData2025 = data2025.features;
            const filteredData2050 = data2050.features;
            
            
            // Draw 2025 cities
            const cities2025 = g.selectAll(".city-2025")
                .data(filteredData2025, function(d) { 
                    return "2025-" + d.properties.Agglomeration_ID;
                });

            cities2025.enter()
                .append("path")
                .attr("class", "city city-2025")
                .attr("d", path)
                .attr("fill", function(d) {
                    const population = d.properties.Population_2025;
                    if (!population || population <= 0) {
                        return "#e0e0e0";
                    }
                    return colorScale(population);
                })
                .attr("title", function(d) {
                    return d.properties.Agglomeration_Name + " (2025) - Population: " + 
                           (d.properties.Population_2025?.toLocaleString() || "N/A");
                })
                .on("click", function(event, d) {
                    event.stopPropagation();
                    showCityInfo(d);
                })
                .style("opacity", currentYear === "2025" ? 1 : 0)
                .style("vector-effect", "non-scaling-stroke");

            // Draw 2050 cities
            const cities2050 = g.selectAll(".city-2050")
                .data(filteredData2050, function(d) { 
                    return "2050-" + d.properties.Agglomeration_ID;
                });

            cities2050.enter()
                .append("path")
                .attr("class", "city city-2050")
                .attr("d", path)
                .attr("fill", function(d) {
                    const population = d.properties.Population_2050;
                    if (!population || population <= 0) {
                        return "#e0e0e0";
                    }
                    return colorScale(population);
                })
                .attr("title", function(d) {
                    return d.properties.Agglomeration_Name + " (2050) - Population: " + 
                           (d.properties.Population_2050?.toLocaleString() || "N/A");
                })
                .on("click", function(event, d) {
                    event.stopPropagation();
                    showCityInfo(d);
                })
                .style("opacity", currentYear === "2050" ? 1 : 0)
                .style("vector-effect", "non-scaling-stroke");

            // Draw merge lines FIRST (so they appear above cities)
            const mergeLines = [];
            
            // Find all merge relationships
            filteredData2025.forEach(sourceCity => {
                const sourceId = sourceCity.properties.Agglomeration_ID;
                const mergedTo = sourceCity.properties.MergedTo;
                
                // Check if this city merges to another city
                if (mergedTo && mergedTo > 0 && mergedTo !== sourceId) {
                    // Find the target city
                    const targetCity = filteredData2025.find(city => 
                        city.properties.Agglomeration_ID === mergedTo
                    );
                    
                    if (targetCity) {
                        mergeLines.push({
                            source: sourceCity,
                            target: targetCity,
                            sourceId: sourceId,
                            targetId: mergedTo
                        });
                    }
                }
            });
            
            
            // Draw the merge lines
            const lines = g.selectAll(".merge-line")
                .data(mergeLines, d => `${d.sourceId}-${d.targetId}`);

            lines.enter()
                .append("line")
                .attr("class", "merge-line")
                .attr("x1", d => path.centroid(d.source)[0])
                .attr("y1", d => path.centroid(d.source)[1])
                .attr("x2", d => path.centroid(d.target)[0])
                .attr("y2", d => path.centroid(d.target)[1])
                .attr("stroke", "#ff4444")
                .attr("stroke-width", 0.8)
                .attr("stroke-dasharray", "1.5,1.5")
                .attr("stroke-opacity", 0.8)
                .style("vector-effect", "non-scaling-stroke")
                .each(function() {
                    const line = d3.select(this);
                    let offset = 0;
                    let lastTime = 0;
                    const targetFPS = 60; // 目标帧率
                    const frameInterval = 1000 / targetFPS; // 每帧间隔时间
                    
                    const animate = function(currentTime) {
                        // 确保动画以恒定速度运行，不受其他动画影响
                        if (currentTime - lastTime >= frameInterval) {
                            offset = (offset + 0.1) % 10;
                            line.attr("stroke-dashoffset", -offset);
                            lastTime = currentTime;
                        }
                        
                        // 使用 setTimeout 而不是 requestAnimationFrame 来避免被其他动画阻塞
                        setTimeout(() => {
                            if (line.node().parentNode) { // 检查元素是否还存在
                                animate(performance.now());
                            }
                        }, 16); // 约60fps
                    };
                    
                    // Start animation only if not already running
                    if (!line.node()._animationRunning) {
                        line.node()._animationRunning = true;
                        animate(performance.now());
                    }
                });

            lines.exit().remove();
            
            // Update opacity for all lines (both new and existing) - always visible, no transition
            g.selectAll(".merge-line")
                .style("opacity", 0.5);  // 线条始终可见，不跟随年份变化，不影响动画速度

            // Update opacity for existing cities based on current year
            g.selectAll(".city-2025")
                .style("opacity", currentYear === "2025" ? 1 : 0);
            
            g.selectAll(".city-2050")
                .style("opacity", currentYear === "2050" ? 1 : 0);
        }
    </script>
    </div>
</body>
</html>
